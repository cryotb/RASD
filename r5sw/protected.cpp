#include "inc/include.h"

void protected_func()
{
    //
    //  (EXTRA) This is an extra check added by me, R5AC will not care for return address for now.
    // 

    auto retaddr = BASE_OF(_ReturnAddress());

    if (!tools::is_code_within_legitimate_memory_region(retaddr))
    {
        printf("<<EXTRA>> [FLAG//////UNBACKED CODE EXECUTION(PRIMARY)] caller is originated within non-module memory.\n");
    }

    auto mod_caller = tools::FindProcessModuleByRIP((HANDLE)-1, retaddr);
    char caller_name[MAX_PATH];
    memset(caller_name, 0, sizeof(caller_name));

    const char* caller_fmt = nullptr;

    if (mod_caller != std::nullopt)
    {
        caller_fmt = "<<EXTRA>> [INFO] CALLED BY '%s'+0x%llx\n";
        strcpy_s(caller_name, mod_caller->m_name.c_str());
    }
    else
    {
        caller_fmt = "<<EXTRA>> [INFO] CALLED BY '%s'\n";
        sprintf_s(caller_name, "UNK_%llx", mod_caller->m_base);
    }

    printf(caller_fmt, caller_name, retaddr - mod_caller->m_base);

    //
    // <===============================================================================>
    //

     // This is where R5AC's stackwalk actually comes into play.
    PVOID backtrace[5];
    RtlZeroMemory(backtrace, sizeof(backtrace));

    // Make a CALL to RtlCaptureStackBackTrace, which will give us a backtrace buffer of the currently recorded return addresses.
    WORD num_captured = RtlCaptureStackBackTrace(1, 5, backtrace, 0);
    if (num_captured > 0)
    {
        // Loop until given range to validate legitimacy of backtrace records.
        for (WORD i = 0; i < num_captured; i++)
        {
            PVOID retaddr = backtrace[i];

            if (!tools::is_code_within_legitimate_memory_region(BASE_OF(retaddr)))
            {
                printf("[FLAG//////UNBACKED CODE EXECUTION(SECONDARY)] suspicious record at %i (%p)\n", i, retaddr);
            }

            if (!tools::retaddr_is_call_insn(retaddr))
            {
                // IF THIS RETURN ADDRESS HAS NOT BEEN GENERATED BY A CALL INSTRUCTION,
                //  PERFORM ADDITIONAL ANALYSIS TO DETERMINE IF A RETURN ADDRESS SPOOFER WAS POTENTIALLY USED.
                DWORD_PTR v50 = BASE_OF(retaddr);
                DWORD_PTR v57 = 2i64;
                while (*(BYTE*)(v50 - v57) != 0xFF || (((*(BYTE*)(v50 - v57 + 1) & 0x38) - 16) & 0xF7) != 0)
                {
                    if (++v57 > 7)
                    {
                        printf("[FLAG//////RETADDR SPOOFER] suspicious record at %i (%p)\n", i, retaddr);
                        break;
                    }
                }
            }
        }
    }
}
